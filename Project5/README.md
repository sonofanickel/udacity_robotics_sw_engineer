# Project 5: Home Service Robot

## Purpose

The purpose of this project is to build a mobile robot that utilizes localization, mapping, object avoidance and path planning to "carry" a simulated 3D object from one location to another.

Tasks to achieve this goal include:
1. Building a simulated world and mobile robot. The robot is equipped with a laser range finder capable of producing `LaserScan` messages to detect the dimensions and obstacles within the world.
2. Utilization of a Simultaneous Localization and Mapping (SLAM) algorithm to build a 2D map of the simulated world. The map will later be provided to a localization and navigation algorithm to perform path planning within the environment.
3. Utilization of a path planning algorithm to navigate within the world while avoiding obstacles and walls enroute to a user-designated pose.


## Building a 2D map using SLAM

The [slam_gmapping](http://wiki.ros.org/slam_gmapping) package is utilized to generate a 2D map that will later be used for localization and path planning.

This package takes as input messages from the robot:
1. Transforms that relate the frames of the robot, lidar, and odometry. These transforms are published by the `robot_state_publisher` package to the `tf` topic.
2. `LaserScan` messages generated by the `Hokuyo` laser rangefinder mounted to the robot and published to the `scan` topic.

The sensor date above is used to generate a map and simultaneously estimate the robot's pose within the map using the Grid-based FastSLAM algorithm.

#### Grid-based FastSLAM Algorithm
Like all particle filter-based algorithms, this algorithm estimates the robot's pose using a set of theoretical particles that are distributed around the robot in space, with random orientations. In addition to storing its x, y, yaw and importance weight each particle in the Grid-based FastSLAM algorithm also stores its history of robot pose estimates and its own version of the map. With this additional data, the SLAM problem is divided into independent and simpler "mapping with known poses" problems for each particle,  which are in turn solved using the Occupancy Grid Mapping algorithm. A basic description of how the Grid-based FastSLAM algorithm works is given below:

* Initially, particles are generated according to some chosen probability distribution, or even randomly and uniformly over the entire pose space. Each particle represents a hypothesis - also known as the posterior belief - of the true robot pose.
* Each iteration of the algorithm takes three inputs:
   * The previous belief of the estimated robot pose
   * The recorded odometry data from the recent movement
   * The current sensor measurements following the movement described by the second input.
* First, the pose of each particle is updated according to the odometry data recorded by the robot
* Next, the weight of each particle is updated by comparing the actual sensor data to an estimate of the sensor data if the measurement had been taken with the pose of the particle. The closer the estimated sensor measurement is to the actual sensor measurement, the higher the weight of the particle.
* Next, the map of each particle is updated using the Occupancy Grid Mapping Algorithm. The "known pose" used for the algorithm is the estimated pose of the particle computed in the first step.
* Finally, the resample step is performed: particles with low weights are removed, and a new set of particles is regenerated according to the distribution of the particles that remained. This will place more particles in the poses that are more likely, and less particles everywhere else.
* The resulting new distribution is provided as the input for the next iteration of the algorithm

#### Occupancy Grid Mapping Algorithm
The Occupancy Grid Mapping algorithm is used to generate a grid map, which is a map that partitions the entire 2D space into a grid of individual cells. Each cell is associated with a value that indicates whether the cell is occupied or not based on the lidar measurement. A basic description of the algorithm is given below:
* Each iteration of the algorithm takes three inputs:
   * The previous belief of the map
   * The current sensor measurement
   * The current belief of the estimated robot pose
* Update each cell in the map: if the cell lies within the perceptual field of the sensor measurement then update the log odds value of the cell.

To compute the log odds of a given cell: add the previous log odds value for the cell to the log odds ratio of the inverse sensor model and subtract the log odd of the initial belief. The initial belief represents the initial state of the system before taking any sensor measurements.

The inverse sensor model function computes log odds representation of the probability of a map cell being occupied, free or unknown by evaluating the cell's location with respect to the measurement conical field of view.

Use of the log odds representation is to ensure that the probability of map cell being occupied is always between zero and one.

#### Occupancy Grid Map
The resulting 2D map is formatted into an `OccupancyGrid` message and published to the `map` topic. The environment is divided into a grid of cells (of configurable resolution), which is implemented in the `OccupancyGrid` message as a one-dimensional integer array where each index in the array represents a cell in the overall map grid. The value at each array index identifies whether the cell is occupied or not with a probability value between 0 - 100. The `map_server` package can be used to convert the current `OccupancyGrid` message into a standard image format where the state of each cell in the map is represented by a pixel, and the color of pixel denotes the occupancy probability of the cell. Whiter pixels are more likely to be free, and blacker pixels are more likely to be occupied. The saved image is later used by `map_server` to convert the image back into an `OccupancyGrid` message published on the `map` topic. A screenshot of the generated map for the environment used in this project can be seen in the map/ directory.

## Localization and Path Planning
The map generated in the previous step is provided to the `amcl` ROS package which is used to localize the robot within map as it moves to user-designated poses. This package uses the Adaptive Monte Carlo Localization (AMCL) algorithm, which is another particle filter-based algorithm.

Path planning is provided by the `move_base` ROS package, which is a major component of the ROS navigation stack.

#### Adaptive Monte Carlo Localization Algorithm
The MCL algorithm is an implementation of a particle filter localization algorithm, and like all localization algorithms the purpose is to estimate the pose of the robot within the given environment. A basic description of how this algorithm works is given below, and is very similar to the Grid-based FastSLAM algorithm described above:

* Initially, particles are generated according to some chosen probability distribution, or even randomly and uniformly over the entire pose space. Each particle represents a hypothesis - or the posterior belief - of the true robot pose.
* Each iteration of the algorithm takes three inputs:
   * The previous belief of the estimated robot pose
   * The recorded odometry data from the recent movement
   * The current sensor measurements following the movement described by the second input.
* First, the pose of each particle is updated according to the odometry data recorded by the robot
* Next, the weight of each particle is updated by comparing the actual sensor data to an estimate of the sensor data if the measurement had been taken with the pose of the particle. The closer the estimated sensor measurement is to the actual sensor measurement, the higher the weight of the particle.
* Finally, the resample step is performed: particles with low weights are removed, and a new set of particles is regenerated according to the distribution of the particles that remained. This will place more particles in the poses that are more likely, and less particles everywhere else.
* The resulting new distribution is provided as the input for the next iteration of the algorithm

The version MCL implemented in this ROS package is known as Adaptive MCL because as the probably distribution narrows the algorithm reduces the number of particles introduced in resampling step. This optimization improves performance of the algorithm as is converges toward the true pose of the robot.

#### Path Planning
Path planning is provided by the `move_base` ROS package. This package contains subcomponents that implement global and local costmaps and planners used in navigation. Sensor measurements, odometry, and transforms are inputs into the `move_base` subcomponents, and the output is a series of `Twist` messages published to the `cmd_vel` topic that instruct the robot's `differential_drive_controller` to move about the environment to achieve the goal position.

In order for a path to be planned, a costmap must first be generated for input to the path planning algorithm. The `costmap_2d` ROS package is used for this purpose, and it takes as input the occupancy grid map generated previously (available on the `map` ROS topic) to generate the global costmap. The costmap partitions the navigation space into cells, and assigns each cell a value depending on whether the cell exists in occupied, unknown, or free space. A cell's value is higher if it falls within the configured "inflation radius" of a nearby occupied cell. This allows the path planning algorithm to steer well clear of obstacles that may cause the robot to get stuck.

`NavfnROS` is used for the global planner. This object implements Dijkstra's algorithm to find an optimal path through the global costmap. Dijkstra's algorithm traverses the cost map in breadth-first order, and prioritizing visiting cells with lower values first. This means that, given a cost map where each cell has an equal weight, the map will be traversed in exactly the same order as a standard Breadth First Search algorithm.

A separate costmap and planner are used for obstacle avoidance and path planning near the robot. These are known as the local costmap and local planner. Generation of the local costmap involves input from the lidar sensor and the already-computed global path. The local path planner computes serval possible trajectories through the local costmap and selects the optimal one.

## Moving Simulated Objects
To simulate the act of moving objects within the world the following ROS packages were developed.

`pick_objects`
Instantiates a ROS node that interacts with the ROS Navigation stack. It sends messages to the navigation stack that instruct the robot to move to the desired location. Once the location is reached (if it is reached), it send a message to the `add_markers` node that informs it which location it has reached (pickup or drop-off) and what the X-Y coordinates of the location is.

`add_markers`
Instantiates a ROS node that creates and deletes Marker objects within the simulated environment. Subscribes to messages published by `pick_objects` that inform it if a Marker object has been picked up or dropped off, and the X-Y location of each event.
